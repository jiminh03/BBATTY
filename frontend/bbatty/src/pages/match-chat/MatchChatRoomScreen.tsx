import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  ScrollView,
  StyleSheet,
  SafeAreaView,
  Alert,
  TextInput,
  KeyboardAvoidingView,
  Platform,
  AppState,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import type { StackNavigationProp } from '@react-navigation/stack';
import type { RouteProp } from '@react-navigation/native';
import { useMatchChatWebSocket } from '../../features/match-chat';
import type { MatchChatRoom } from '../../entities/chat-room/api/types';
import type { ChatMessage, MatchChatMessage, SystemMessage } from '../../features/match-chat';
import type { ChatStackParamList } from '../../navigation/types';
import { useUserStore } from '../../entities/user/model/userStore';
import { useThemeColor } from '../../shared/team/ThemeContext';

type NavigationProp = StackNavigationProp<ChatStackParamList>;
type RoutePropType = RouteProp<ChatStackParamList, 'MatchChatRoom'>;

export const MatchChatRoomScreen = () => {
  const navigation = useNavigation<NavigationProp>();
  const route = useRoute<RoutePropType>();
  const { room, websocketUrl, sessionToken } = route.params;
  const themeColor = useThemeColor();
  
  // ÏõåÏπòÏ±ÑÌåÖ Ïó¨Î∂Ä ÌôïÏù∏
  const isWatchChat = websocketUrl.includes('/ws/watch-chat/') || (websocketUrl.includes('gameId=') && websocketUrl.includes('teamId='));
  
  console.log('MatchChatRoomScreen route.params:', route.params);
  
  const [currentMessage, setCurrentMessage] = useState('');
  const getCurrentUser = useUserStore((state) => state.getCurrentUser);
  const currentUser = getCurrentUser();
  const currentUserId = currentUser?.userId || 45; // fallback to test ID that matches log
  
  console.log('Current User:', currentUser);
  console.log('Current User ID:', currentUserId);
  
  const scrollViewRef = useRef<ScrollView>(null);

  const scrollToBottom = () => {
    setTimeout(() => {
      scrollViewRef.current?.scrollToEnd({ animated: true });
    }, 50);
  };

  // Í∏∞Ï°¥ WebSocket Î°úÏßÅ Îã§Ïãú ÏÇ¨Ïö©
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [ws, setWs] = useState<WebSocket | null>(null);
  const [connectionStatus, setConnectionStatus] = useState<'DISCONNECTED' | 'CONNECTING' | 'CONNECTED' | 'ERROR'>('DISCONNECTED');
  const [sentMessages, setSentMessages] = useState<Set<string>>(new Set());
  const [appState, setAppState] = useState(AppState.currentState);
  const [isReconnecting, setIsReconnecting] = useState(false);

  const addMessage = (message: ChatMessage, isMyMessage: boolean = false) => {
    setMessages(prev => {
      const isDuplicate = prev.some(m => 
        m.timestamp === message.timestamp && 
        m.content === message.content
      );
      
      if (isDuplicate) return prev;
      
      const markedMessage = {
        ...message,
        _isMyMessage: isMyMessage
      };
      
      const newMessages = [...prev, markedMessage];
      newMessages.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
      
      if (newMessages.length > 100) {
        return newMessages.slice(-100);
      }
      return newMessages;
    });
  };

  // Î©îÏãúÏßÄÍ∞Ä ÏóÖÎç∞Ïù¥Ìä∏Îê† ÎïåÎßàÎã§ Ïä§ÌÅ¨Î°§ÏùÑ ÌïòÎã®ÏúºÎ°ú
  useEffect(() => {
    if (messages.length > 0) {
      scrollToBottom();
    }
  }, [messages]);

  const connectToWebSocket = () => {
    try {
      setConnectionStatus('CONNECTING');
      
      // ÏïàÎìúÎ°úÏù¥Îìú ÏóêÎÆ¨Î†àÏù¥ÌÑ∞Ïö© URL Î≥ÄÍ≤Ω
      let wsUrl = websocketUrl;
      if (wsUrl && wsUrl.includes('localhost')) {
        wsUrl = wsUrl.replace('localhost', '10.0.2.2');
      }
      
      // WebSocket URL Í≤ÄÏ¶ù Î∞è ÏàòÏ†ï
      if (wsUrl && !wsUrl.startsWith('ws://') && !wsUrl.startsWith('wss://')) {
        if (wsUrl.startsWith('http://')) {
          wsUrl = wsUrl.replace('http://', 'ws://');
        } else if (wsUrl.startsWith('https://')) {
          wsUrl = wsUrl.replace('https://', 'wss://');
        }
      }
      
      // ÏÑúÎ≤Ñ Ïó∞Í≤∞ Î¨∏Ï†úÎ°ú Ïù∏Ìïú ÏûÑÏãú Ïö∞Ìöå: Îç∞Î™®Ïö© WebSocket Ïó∞Í≤∞ ÏãúÎÆ¨Î†àÏù¥ÏÖò
      // mock ÌÜ†ÌÅ∞Ïù¥ ÏûàÎäî Í≤ΩÏö∞ÏóêÎßå Îç∞Î™® Î™®Îìú ÏÇ¨Ïö©
      if (wsUrl && wsUrl.includes('i13a403.p.ssafy.io:8084') && sessionToken && sessionToken.startsWith('mock_session_token')) {
        console.log('‚ö†Ô∏è ÏÑúÎ≤Ñ WebSocket Ïó∞Í≤∞ Î¨∏Ï†úÎ°ú Ïù∏Ìïú ÏûÑÏãú Îç∞Î™® Î™®Îìú (Î™© ÌÜ†ÌÅ∞ Í∞êÏßÄ)');
        // Ïó∞Í≤∞ ÏÑ±Í≥µÏúºÎ°ú ÏãúÎÆ¨Î†àÏù¥ÏÖò
        setTimeout(() => {
          setConnectionStatus('CONNECTED');
          console.log('üì° Îç∞Î™® Î™®Îìú: Ïó∞Í≤∞ ÏÑ±Í≥µÏúºÎ°ú ÏãúÎÆ¨Î†àÏù¥ÏÖòÎê®');
          
          // ÏÉòÌîå Î©îÏãúÏßÄ Ï∂îÍ∞Ä
          const welcomeMessage = {
            messageType: 'SYSTEM' as const,
            content: 'Ï±ÑÌåÖÎ∞©Ïóê Ïó∞Í≤∞ÎêòÏóàÏäµÎãàÎã§. (Îç∞Î™® Î™®Îìú)',
            timestamp: new Date().toISOString(),
            userId: 'system',
            nickname: 'System'
          };
          addMessage(welcomeMessage, false);
        }, 1000);
        
        return;
      }
      
      console.log('ÏõπÏÜåÏºì Ïó∞Í≤∞ ÏãúÏûë');
      console.log('ÏõêÎ≥∏ websocketUrl:', websocketUrl);
      console.log('sessionToken:', sessionToken);
      console.log(`ÏµúÏ¢Ö wsUrl: ${wsUrl}`);

      if (!wsUrl) {
        console.error('ÏõπÏÜåÏºì URLÏù¥ ÏóÜÏäµÎãàÎã§!');
        setConnectionStatus('DISCONNECTED');
        return;
      }

      // WebSocket Ïó∞Í≤∞ (React NativeÏóêÏÑúÎäî ÏòµÏÖò Í∞ùÏ≤¥Î•º ÏßÄÏõêÌïòÏßÄ ÏïäÏùå)
      const websocket = new WebSocket(wsUrl);
      setWs(websocket);

      websocket.onopen = () => {
        setConnectionStatus('CONNECTED');
        console.log('ÏõπÏÜåÏºì Ïó∞Í≤∞ ÏÑ±Í≥µ');
        
        // Îß§ÏπòÏ±ÑÌåÖÍ≥º ÏßÅÍ¥ÄÏ±ÑÌåÖ Î™®Îëê ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Ï†ÑÏÜ°
        const isWatchChat = wsUrl.includes('/ws/watch-chat/') || (wsUrl.includes('gameId=') && wsUrl.includes('teamId='));
        
        let authData;
        if (isWatchChat) {
          // ÏßÅÍ¥ÄÏ±ÑÌåÖÏö© Ïù∏Ï¶ù Îç∞Ïù¥ÌÑ∞
          authData = {
            gameId: room.gameId || '1258',
            teamId: currentUser?.teamId || 3,
            nickname: currentUser?.nickname || 'Anonymous',
            userId: currentUser?.userId || currentUserId
          };
        } else {
          // Îß§ÏπòÏ±ÑÌåÖÏö© Ïù∏Ï¶ù Îç∞Ïù¥ÌÑ∞
          authData = {
            matchId: room.matchId,
            nickname: currentUser?.nickname || 'Anonymous',
            winRate: 75,
            profileImgUrl: currentUser?.profileImageURL || '',
            isWinFairy: false
          };
        }
        
        console.log('üîê WebSocket Ïù∏Ï¶ù Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ° (', isWatchChat ? 'ÏßÅÍ¥ÄÏ±ÑÌåÖ' : 'Îß§ÏπòÏ±ÑÌåÖ', '):', JSON.stringify(authData, null, 2));
        websocket.send(JSON.stringify(authData));
      };

      websocket.onmessage = (event) => {
        try {
          const messageData = JSON.parse(event.data);
          console.log('Î©îÏãúÏßÄ ÏàòÏã†:', messageData);
          
          // timestamp ÌòïÏãù ÌÜµÏùº (Ïà´ÏûêÏù∏ Í≤ΩÏö∞ ISO Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò)
          if (typeof messageData.timestamp === 'number') {
            messageData.timestamp = new Date(messageData.timestamp).toISOString();
          }
          
          const messageKey = `${messageData.content}_${messageData.timestamp}`;
          const isMyMessage = sentMessages.has(messageKey);
          
          // Îß§ÏπòÏ±ÑÌåÖ: messageType === 'CHAT', ÏßÅÍ¥ÄÏ±ÑÌåÖ: type === 'CHAT_MESSAGE'
          if (messageData.messageType === 'CHAT' || messageData.type === 'CHAT_MESSAGE') {
            // ÏÑúÎ≤Ñ Î≤ÑÍ∑∏Î°ú Ïù∏Ìï¥ JSON Í∞ùÏ≤¥ ÏûêÏ≤¥Í∞Ä Î©îÏãúÏßÄ ÎÇ¥Ïö©ÏúºÎ°ú Ïò§Îäî Í≤ΩÏö∞ ÌïÑÌÑ∞ÎßÅ
            const content = messageData.content || '';
            const isJsonMessage = typeof content === 'string' && (
              content.startsWith('{') || 
              content.includes('"messageType"') ||
              content.includes('"nickname"') ||
              content.includes('"userId"') ||
              content.includes('"roomId"') ||
              content.includes('"timestamp"')
            );
              
            if (!isJsonMessage) {
              addMessage(messageData, isMyMessage);
              console.log('‚úÖ Ï†ïÏÉÅ Î©îÏãúÏßÄ Ï∂îÍ∞Ä:', content);
            } else {
              console.log('üö´ JSON Í∞ùÏ≤¥ Î©îÏãúÏßÄ ÌïÑÌÑ∞ÎßÅÎê®:', content);
            }
            
            if (isMyMessage) {
              setSentMessages(prev => {
                const newSet = new Set(prev);
                newSet.delete(messageKey);
                return newSet;
              });
            }
          } else if (
              messageData.messageType === 'USER_JOIN' ||
              messageData.messageType === 'USER_LEAVE'
            ) {
              addMessage(messageData, false);
            }
        } catch (error) {
          console.error('Î©îÏãúÏßÄ ÌååÏã± Ïò§Î•ò:', error);
        }
      };

      websocket.onclose = (event) => {
        setConnectionStatus('DISCONNECTED');
        console.log(`ÏõπÏÜåÏºì Ïó∞Í≤∞ Ï¢ÖÎ£å: ${event.code} - ${event.reason}`);
        
        // Ï†ïÏÉÅ Ï¢ÖÎ£å(1000)Í∞Ä ÏïÑÎãå Í≤ΩÏö∞ Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ
        if (event.code !== 1000 && !isReconnecting && appState === 'active') {
          setIsReconnecting(true);
          console.log('üîÑ ÎπÑÏ†ïÏÉÅ Ï¢ÖÎ£åÎ°ú Ïù∏Ìïú Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ...');
          setTimeout(() => {
            if (appState === 'active') {
              connectToWebSocket();
            }
            setIsReconnecting(false);
          }, 3000);
        }
      };

      websocket.onerror = (error) => {
        setConnectionStatus('ERROR');
        console.error('ÏõπÏÜåÏºì Ïò§Î•ò:', error);
        console.log('ÏõπÏÜåÏºì Ïò§Î•ò ÏÉÅÏÑ∏:', JSON.stringify(error, null, 2));
        
        // Ïû¨Ïó∞Í≤∞ Ï§ëÏù¥ ÏïÑÎãàÍ≥† Ïï±Ïù¥ ÌôúÏÑ± ÏÉÅÌÉúÏùº ÎïåÎßå Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ
        if (!isReconnecting && appState === 'active') {
          setIsReconnecting(true);
          setTimeout(() => {
            if (appState === 'active') {
              console.log('üîÑ ÏóêÎü¨Î°ú Ïù∏Ìïú Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ...');
              connectToWebSocket();
            }
            setIsReconnecting(false);
          }, 3000);
        }
      };

    } catch (error) {
      console.error('ÏõπÏÜåÏºì Ïó∞Í≤∞ Ïò§Î•ò:', error);
      setConnectionStatus('ERROR');
    }
  };

  const disconnect = () => {
    if (ws) {
      ws.close();
      setWs(null);
      setConnectionStatus('DISCONNECTED');
      setSentMessages(new Set());
      console.log('ÏõπÏÜåÏºì Ïó∞Í≤∞ Ìï¥Ï†ú');
    }
  };

  const sendMessage = () => {
    if (!currentMessage.trim()) {
      Alert.alert('ÏïåÎ¶º', 'Î©îÏãúÏßÄÎ•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
      return;
    }

    if (ws && ws.readyState === WebSocket.OPEN) {
      try {
        const messageContent = currentMessage.trim();
        const timestamp = new Date().toISOString();
        
        const messageKey = `${messageContent}_${timestamp}`;
        setSentMessages(prev => new Set([...prev, messageKey]));
        
        ws.send(messageContent);
        setCurrentMessage('');
        console.log('Î©îÏãúÏßÄ Ï†ÑÏÜ°:', messageContent);
        
        // Î©îÏãúÏßÄ Ï†ÑÏÜ° ÌõÑ Ïä§ÌÅ¨Î°§
        scrollToBottom();
      } catch (error) {
        console.error('Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïò§Î•ò:', error);
        Alert.alert('Ï†ÑÏÜ° Ïò§Î•ò', 'Î©îÏãúÏßÄ Ï†ÑÏÜ°Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
      }
    } else {
      Alert.alert('Ïò§Î•ò', 'Ï±ÑÌåÖÎ∞©Ïóê Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
    }
  };

  const formatTime = (timestamp: string): string => {
    const date = new Date(timestamp);
    const hours = date.getHours().toString().padStart(2, '0');
    const minutes = date.getMinutes().toString().padStart(2, '0');
    return `${hours}:${minutes}`;
  };

  const getStatusColor = (): string => {
    switch (connectionStatus) {
      case 'CONNECTED': return '#4CAF50';
      case 'CONNECTING': return '#FF9800';
      case 'ERROR': return '#F44336';
      default: return '#9E9E9E';
    }
  };

  const renderMessage = (message: ChatMessage & { _isMyMessage?: boolean }, index: number) => {
    if (
      message.messageType === 'USER_JOIN' ||
      message.messageType === 'USER_LEAVE'
    ) {
      const systemMsg = message as SystemMessage;
      const systemText =
        systemMsg.messageType === 'USER_JOIN'
          ? `${systemMsg.userName || 'ÏÇ¨Ïö©Ïûê'}ÎãòÏù¥ ÏûÖÏû•ÌñàÏäµÎãàÎã§.`
          : `${systemMsg.userName || 'ÏÇ¨Ïö©Ïûê'}ÎãòÏù¥ Ìá¥Ïû•ÌñàÏäµÎãàÎã§.`;

      return (
        <View key={index} style={styles.systemMessageContainer}>
          <Text style={styles.systemMessageText}>{systemText}</Text>
        </View>
      );
    }

    const isMyMessage = 'userId' in message && message.userId === currentUserId;

    return (
      <View key={index} style={[
        styles.messageContainer,
        isMyMessage ? styles.myMessageContainer : styles.otherMessageContainer
      ]}>
        {!isMyMessage && 'nickname' in message && (
          <Text style={styles.nicknameText}>{message.nickname}</Text>
        )}
        
        <View style={[
          styles.messageBubble,
          isMyMessage ? styles.myMessageBubble : styles.otherMessageBubble
        ]}>
          <Text style={[
            styles.messageText,
            isMyMessage ? styles.myMessageText : styles.otherMessageText
          ]}>
            {message.content}
          </Text>
          <Text style={[
            styles.timeText,
            isMyMessage ? styles.myTimeText : styles.otherTimeText
          ]}>
            {formatTime(message.timestamp)}
          </Text>
        </View>
      </View>
    );
  };

  useEffect(() => {
    connectToWebSocket();
    
    return () => {
      disconnect();
    };
  }, []);

  // Ïï± ÏÉÅÌÉú Î≥ÄÌôî Í∞êÏßÄ
  useEffect(() => {
    const handleAppStateChange = (nextAppState: string) => {
      console.log('üì± Ïï± ÏÉÅÌÉú Î≥ÄÌôî:', appState, '‚Üí', nextAppState);
      
      if (appState.match(/inactive|background/) && nextAppState === 'active') {
        console.log('üì± Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú Î≥µÍ∑Ä - WebSocket Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ');
        // Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú Ìè¨Í∑∏ÎùºÏö¥ÎìúÎ°ú ÎèåÏïÑÏôîÏùÑ Îïå
        if (ws && ws.readyState !== WebSocket.OPEN) {
          setTimeout(() => {
            connectToWebSocket();
          }, 1000);
        }
      } else if (nextAppState.match(/inactive|background/)) {
        console.log('üì± Î∞±Í∑∏ÎùºÏö¥ÎìúÎ°ú Ïù¥Îèô - WebSocket Ïó∞Í≤∞ Ï†ïÎ¶¨');
        // Î∞±Í∑∏ÎùºÏö¥ÎìúÎ°ú Í∞à Îïå Ïó∞Í≤∞ Ï†ïÎ¶¨
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.close(1000, 'App going to background');
        }
      }
      
      setAppState(nextAppState);
    };

    const subscription = AppState.addEventListener('change', handleAppStateChange);
    return () => subscription?.remove();
  }, [appState, ws]);

  useEffect(() => {
    const unsubscribe = navigation.addListener('beforeRemove', () => {
      disconnect();
    });

    return unsubscribe;
  }, [navigation]);

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView 
        style={styles.container}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      >
        <View style={[styles.header, { backgroundColor: themeColor }]}>
          <TouchableOpacity onPress={() => {
            if (navigation.canGoBack()) {
              navigation.goBack();
            }
          }}>
            <Text style={styles.backButton}>‚Üê ÎÇòÍ∞ÄÍ∏∞</Text>
          </TouchableOpacity>
          <Text style={styles.title}>
            {isWatchChat ? 'ÏßÅÍ¥ÄÏ±ÑÌåÖ' : room.matchTitle}
          </Text>
          <View style={styles.statusContainer}>
            <View style={[
              styles.statusIndicator,
              { backgroundColor: getStatusColor() }
            ]} />
            <Text style={styles.statusText}>{connectionStatus}</Text>
          </View>
        </View>

        <ScrollView 
          ref={scrollViewRef}
          style={styles.messagesContainer}
          contentContainerStyle={styles.messagesContent}
          showsVerticalScrollIndicator={false}
        >
          {messages.length === 0 ? (
            <View style={styles.emptyContainer}>
              <Text style={styles.emptyText}>
                {connectionStatus === 'CONNECTED' 
                  ? 'ÏïÑÏßÅ Î©îÏãúÏßÄÍ∞Ä ÏóÜÏäµÎãàÎã§.\nÏ≤´ Î≤àÏß∏ Î©îÏãúÏßÄÎ•º Î≥¥ÎÇ¥Î≥¥ÏÑ∏Ïöî!' 
                  : 'Ï±ÑÌåÖÎ∞©Ïóê Ïó∞Í≤∞Ï§ëÏûÖÎãàÎã§...'}
              </Text>
            </View>
          ) : (
            messages.map(renderMessage)
          )}
        </ScrollView>

        {connectionStatus === 'CONNECTED' && (
          <View style={styles.inputContainer}>
            <TextInput
              style={styles.textInput}
              value={currentMessage}
              onChangeText={setCurrentMessage}
              placeholder="Î©îÏãúÏßÄÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî..."
              placeholderTextColor="#999"
              multiline={true}
              maxLength={500}
              onSubmitEditing={sendMessage}
              blurOnSubmit={false}
            />
            <TouchableOpacity 
              style={[
                styles.sendButton,
                !currentMessage.trim() && styles.sendButtonDisabled
              ]}
              onPress={sendMessage}
              disabled={!currentMessage.trim()}
            >
              <Text style={styles.sendButtonText}>Ï†ÑÏÜ°</Text>
            </TouchableOpacity>
          </View>
        )}
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 16,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 4,
    },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 8,
  },
  backButton: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  title: {
    fontSize: 20,
    fontWeight: '900',
    color: '#ffffff',
    flex: 1,
    textAlign: 'center',
    marginHorizontal: 16,
    textShadowColor: 'rgba(0,0,0,0.3)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
  },
  statusContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  statusIndicator: {
    width: 8,
    height: 8,
    borderRadius: 4,
    marginRight: 6,
  },
  statusText: {
    fontSize: 12,
    color: '#ffffff',
    fontWeight: '500',
  },
  messagesContainer: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  messagesContent: {
    padding: 16,
    flexGrow: 1,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 40,
  },
  emptyText: {
    fontSize: 16,
    color: '#999',
    textAlign: 'center',
    lineHeight: 24,
  },
  messageContainer: {
    marginBottom: 12,
    maxWidth: '80%',
  },
  myMessageContainer: {
    alignSelf: 'flex-end',
    alignItems: 'flex-end',
  },
  otherMessageContainer: {
    alignSelf: 'flex-start',
    alignItems: 'flex-start',
  },
  nicknameText: {
    fontSize: 12,
    color: '#666',
    marginBottom: 4,
    marginLeft: 4,
  },
  messageBubble: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 18,
    maxWidth: '100%',
  },
  myMessageBubble: {
    backgroundColor: '#007AFF',
    borderBottomRightRadius: 4,
  },
  otherMessageBubble: {
    backgroundColor: '#fff',
    borderBottomLeftRadius: 4,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  messageText: {
    fontSize: 16,
    lineHeight: 20,
    marginBottom: 4,
  },
  myMessageText: {
    color: '#fff',
  },
  otherMessageText: {
    color: '#333',
  },
  timeText: {
    fontSize: 10,
    alignSelf: 'flex-end',
  },
  myTimeText: {
    color: 'rgba(255, 255, 255, 0.7)',
  },
  otherTimeText: {
    color: '#999',
  },
  systemMessageContainer: {
    alignItems: 'center',
    marginVertical: 8,
  },
  systemMessageText: {
    fontSize: 12,
    color: '#999',
    backgroundColor: 'rgba(0, 0, 0, 0.05)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 12,
  },
  inputContainer: {
    flexDirection: 'row',
    padding: 16,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderTopColor: '#eee',
    alignItems: 'flex-end',
  },
  textInput: {
    flex: 1,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 20,
    paddingHorizontal: 16,
    paddingVertical: 10,
    fontSize: 16,
    maxHeight: 80,
    marginRight: 8,
    backgroundColor: '#f8f9fa',
  },
  sendButton: {
    backgroundColor: '#007AFF',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  sendButtonDisabled: {
    backgroundColor: '#ccc',
  },
  sendButtonText: {
    color: '#fff',
    fontWeight: 'bold',
    fontSize: 14,
  },
});