import React, { useState, useEffect, useRef, useCallback } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  ScrollView,
  FlatList,
  Alert,
  TextInput,
  KeyboardAvoidingView,
  Platform,
  AppState,
  Image,
  ActivityIndicator,
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import NetInfo from '@react-native-community/netinfo';
import { useNavigation, useRoute } from '@react-navigation/native';
import type { StackNavigationProp } from '@react-navigation/stack';
import type { RouteProp } from '@react-navigation/native';
import type { MatchChatRoom } from '../../entities/chat-room/api/types';
import type { ChatMessage, MatchChatMessage, SystemMessage, MessageWithStatus, ExtendedConnectionStatus, ChatNotification } from '../../features/match-chat';
import type { ChatStackParamList } from '../../navigation/types';
import { useMessageQueue } from '../../features/match-chat/hooks/useMessageQueue';
import { useChatNotifications } from '../../features/match-chat/hooks/useChatNotifications';
import { ChatNotificationManager } from '../../features/match-chat/components/ChatNotification';
import { ConnectionStatusIndicator, SimpleConnectionStatus } from '../../features/match-chat/components/ConnectionStatus';
import { MessageStatusIndicator, SimpleMessageStatus } from '../../features/match-chat/components/MessageStatus';
import { getErrorMessage, logChatError } from '../../shared/utils/error';
import { useUserStore } from '../../entities/user/model/userStore';
import { useThemeColor } from '../../shared/team/ThemeContext';
import { styles } from './MatchChatRoomScreen.styles';
import { gameApi } from '../../entities/game/api/api';

type NavigationProp = StackNavigationProp<ChatStackParamList>;
type RoutePropType = RouteProp<ChatStackParamList, 'MatchChatRoom'>;

export const MatchChatRoomScreen = () => {
  const navigation = useNavigation<NavigationProp>();
  const route = useRoute<RoutePropType>();
  const insets = useSafeAreaInsets();
  const { room, websocketUrl, sessionToken } = route.params;
  const themeColor = useThemeColor();
  
  // ÏõåÏπòÏ±ÑÌåÖ Ïó¨Î∂Ä ÌôïÏù∏
  const isWatchChat = websocketUrl.includes('/ws/watch-chat/') || (websocketUrl.includes('gameId=') && websocketUrl.includes('teamId='));
  
  const [currentMessage, setCurrentMessage] = useState('');
  const getCurrentUser = useUserStore((state) => state.getCurrentUser);
  const currentUser = getCurrentUser();
  const currentUserId = currentUser?.userId || 45;
  
  const flatListRef = useRef<FlatList>(null);

  // üîß FIX 1: refÎ°ú ÏÉÅÌÉú Í¥ÄÎ¶¨ÌïòÏó¨ Î¨¥Ìïú Î£®ÌîÑ Î∞©ÏßÄ
  const connectionStateRef = useRef({
    isConnecting: false,
    isConnected: false,
    reconnectAttempts: 0,
    maxReconnectAttempts: 3,
    lastReconnectTime: 0,
    reconnectCooldown: 5000, // 5Ï¥à Ïø®Îã§Ïö¥
    isDestroyed: false,
    reconnectTimer: null as NodeJS.Timeout | null,
  });

  const [messages, setMessages] = useState<MessageWithStatus[]>([]);
  const [ws, setWs] = useState<WebSocket | null>(null);
  const [connectionStatus, setConnectionStatus] = useState<ExtendedConnectionStatus>('DISCONNECTED');
  const [sentMessages, setSentMessages] = useState<Set<string>>(new Set());
  const [appState, setAppState] = useState(AppState.currentState);
  const [networkConnected, setNetworkConnected] = useState(true);
  const [isInitialLoad, setIsInitialLoad] = useState(true);
  const [gameInfo, setGameInfo] = useState<any>(null);
  const [isLoadingOlderMessages, setIsLoadingOlderMessages] = useState(false);
  const [hasOlderMessages, setHasOlderMessages] = useState(true); // ÎÇòÏ§ëÏóê Î∞±ÏóîÎìú API Ïó∞ÎèôÏãú ÏÇ¨Ïö©
  
  // ÏÇ¨Ïö©Ïûê ÏπúÌôîÏ†Å Í∏∞Îä•Îì§
  const {
    notifications,
    dismissNotification,
    showConnectionNotification,
    showErrorNotification,
    showMessageNotification,
  } = useChatNotifications();

  const {
    pendingMessages,
    addMessageToQueue,
    retryMessage,
    removeMessage,
    flushQueue,
  } = useMessageQueue({
    onSendMessage: async (content: string) => {
      if (ws?.readyState === WebSocket.OPEN) {
        try {
          ws.send(content);
          return true;
        } catch (error) {
          console.error('WebSocket send error:', error);
          return false;
        }
      }
      return false;
    },
    isConnected: connectionStatus === 'CONNECTED',
    maxRetries: 3,
  });

  const scrollToBottom = useCallback((animated: boolean = false) => {
    if (messages.length === 0) return;
    
    if (animated) {
      setTimeout(() => {
        flatListRef.current?.scrollToEnd({ animated: true });
      }, 50);
    } else {
      // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏóÜÏù¥ Ï¶âÏãú Ïä§ÌÅ¨Î°§
      flatListRef.current?.scrollToEnd({ animated: false });
    }
  }, [messages.length]);

  // Ïù¥Ï†Ñ Î©îÏãúÏßÄ Î°úÎìú (Î∞±ÏóîÎìú API Ï§ÄÎπÑÏãú Íµ¨ÌòÑ)
  const loadOlderMessages = useCallback(async () => {
    if (isLoadingOlderMessages || !hasOlderMessages) return;
    
    setIsLoadingOlderMessages(true);
    
    try {
      // TODO: Î∞±ÏóîÎìú API Ïó∞ÎèôÏãú Íµ¨ÌòÑ
      // const oldestMessage = messages[0];
      // const olderMessages = await chatApi.getMessageHistory(room.matchId, oldestMessage?.timestamp);
      
      // ÏûÑÏãúÎ°ú 2Ï¥à ÌõÑ ÏôÑÎ£å Ï≤òÎ¶¨
      await new Promise(resolve => setTimeout(resolve, 2000));
      console.log('Ïù¥Ï†Ñ Î©îÏãúÏßÄ Î°úÎìú Í∏∞Îä• - Î∞±ÏóîÎìú API Ï§ÄÎπÑ Ï§ë');
      
    } catch (error) {
      console.error('Ïù¥Ï†Ñ Î©îÏãúÏßÄ Î°úÎìú Ïã§Ìå®:', error);
    } finally {
      setIsLoadingOlderMessages(false);
    }
  }, [isLoadingOlderMessages, hasOlderMessages, messages, room.matchId]);

  const addMessage = useCallback((message: ChatMessage, isMyMessage: boolean = false) => {
    setMessages(prev => {
      const isDuplicate = prev.some(m => 
        m.timestamp === message.timestamp && 
        m.content === message.content
      );
      
      if (isDuplicate) return prev;
      
      const markedMessage = {
        ...message,
        _isMyMessage: isMyMessage
      };
      
      const newMessages = [...prev, markedMessage];
      newMessages.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
      
      return newMessages;
    });
  }, []);

  // üîß FIX 2: Ïû¨Ïó∞Í≤∞ Ïø®Îã§Ïö¥ Î∞è Ï§ëÎ≥µ Î∞©ÏßÄ Î°úÏßÅ Ï∂îÍ∞Ä
  const canReconnect = useCallback((): boolean => {
    const state = connectionStateRef.current;
    const now = Date.now();
    
    if (state.isDestroyed) return false;
    if (state.isConnecting) return false;
    if (state.isConnected) return false;
    if (state.reconnectAttempts >= state.maxReconnectAttempts) return false;
    if (now - state.lastReconnectTime < state.reconnectCooldown) return false;
    if (!networkConnected) return false;
    if (appState !== 'active') return false;
    
    return true;
  }, [networkConnected, appState]);

  const clearReconnectTimer = useCallback(() => {
    if (connectionStateRef.current.reconnectTimer) {
      clearTimeout(connectionStateRef.current.reconnectTimer);
      connectionStateRef.current.reconnectTimer = null;
    }
  }, []);

  const connectToWebSocket = useCallback(async () => {
    const state = connectionStateRef.current;
    
    // üîß FIX 3: Ï§ëÎ≥µ Ïó∞Í≤∞ Î∞©ÏßÄ Í∞ïÌôî
    if (state.isDestroyed) {
      console.log('üì± Ïª¥Ìè¨ÎÑåÌä∏Í∞Ä Ïñ∏ÎßàÏö¥Ìä∏Îê® - Ïó∞Í≤∞ ÏãúÎèÑ Ï§ëÎã®');
      return;
    }

    if (!canReconnect()) {
      console.log('üì± Ïû¨Ïó∞Í≤∞ Ï°∞Í±¥ Î∂àÏ∂©Ï°± - Ïó∞Í≤∞ ÏãúÎèÑ Ï§ëÎã®');
      return;
    }

    try {
      const netState = await NetInfo.fetch();
      if (!netState.isConnected) {
        console.log('üåê ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ ÏóÜÏùå - WebSocket Ïó∞Í≤∞ ÏãúÎèÑ Ï§ëÎã®');
        setConnectionStatus('ERROR');
        return;
      }

      // Í∏∞Ï°¥ WebSocket Ï†ïÎ¶¨
      if (ws) {
        ws.close(1000, 'New connection attempt');
        setWs(null);
      }

      state.isConnecting = true;
      state.lastReconnectTime = Date.now();
      setConnectionStatus('CONNECTING');
      
      console.log(`üì± WebSocket Ïó∞Í≤∞ ÏãúÎèÑ (${state.reconnectAttempts + 1}/${state.maxReconnectAttempts})`);
      
      let wsUrl = websocketUrl;
      if (wsUrl && wsUrl.includes('localhost')) {
        wsUrl = wsUrl.replace('localhost', '10.0.2.2');
      }
      
      if (wsUrl && !wsUrl.startsWith('ws://') && !wsUrl.startsWith('wss://')) {
        if (wsUrl.startsWith('http://')) {
          wsUrl = wsUrl.replace('http://', 'ws://');
        } else if (wsUrl.startsWith('https://')) {
          wsUrl = wsUrl.replace('https://', 'wss://');
        }
      }
      
      // Mock Ï≤òÎ¶¨ Î°úÏßÅ (Í∏∞Ï°¥Í≥º ÎèôÏùº)
      if (wsUrl && wsUrl.includes('i13a403.p.ssafy.io:8083') && sessionToken && sessionToken.startsWith('mock_session_token')) {
        console.log('‚ö†Ô∏è ÏÑúÎ≤Ñ WebSocket Ïó∞Í≤∞ Î¨∏Ï†úÎ°ú Ïù∏Ìïú ÏûÑÏãú Îç∞Î™® Î™®Îìú');
        setTimeout(() => {
          if (!state.isDestroyed) {
            state.isConnecting = false;
            state.isConnected = true;
            state.reconnectAttempts = 0;
            setConnectionStatus('CONNECTED');
            console.log('üì° Îç∞Î™® Î™®Îìú: Ïó∞Í≤∞ ÏÑ±Í≥µ');
          }
        }, 1000);
        return;
      }

      if (!wsUrl) {
        console.error('ÏõπÏÜåÏºì URLÏù¥ ÏóÜÏäµÎãàÎã§!');
        state.isConnecting = false;
        setConnectionStatus('ERROR');
        return;
      }

      const websocket = new WebSocket(wsUrl);
      setWs(websocket);

      // üîß FIX 4: Ïó∞Í≤∞ ÌÉÄÏûÑÏïÑÏõÉ Ï∂îÍ∞Ä
      const connectionTimeout = setTimeout(() => {
        if (state.isConnecting) {
          console.log('üì± WebSocket Ïó∞Í≤∞ ÌÉÄÏûÑÏïÑÏõÉ');
          websocket.close();
          state.isConnecting = false;
          setConnectionStatus('ERROR');
          scheduleReconnect();
        }
      }, 10000); // 10Ï¥à ÌÉÄÏûÑÏïÑÏõÉ

      websocket.onopen = () => {
        clearTimeout(connectionTimeout);
        if (state.isDestroyed) return;
        
        state.isConnecting = false;
        state.isConnected = true;
        state.reconnectAttempts = 0; // ÏÑ±Í≥µ Ïãú Î¶¨ÏÖã
        setConnectionStatus('CONNECTED');
        console.log('üì° WebSocket Ïó∞Í≤∞ ÏÑ±Í≥µ');
        
        // ÏÇ¨Ïö©ÏûêÏóêÍ≤å Ïó∞Í≤∞ ÏÑ±Í≥µ ÏïåÎ¶º
        showConnectionNotification('CONNECTED');
        
        // ÎåÄÍ∏∞ Ï§ëÏù∏ Î©îÏãúÏßÄÎì§ Ïû¨Ï†ÑÏÜ° ÏãúÎèÑ
        // await flushQueue();
        
        // Ïù∏Ï¶ù Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ° (Í∏∞Ï°¥ Î°úÏßÅ Ïú†ÏßÄ)
        let authData;
        if (isWatchChat) {
          if (!currentUser?.teamId) {
            console.warn('‚ö†Ô∏è ÏÇ¨Ïö©Ïûê teamIdÍ∞Ä ÏóÜÏäµÎãàÎã§. Í∏∞Î≥∏Í∞í(ÎëêÏÇ∞) ÏÇ¨Ïö©');
          }
          authData = {
            type: 'AUTH',
            gameId: room.gameId || '1303',
            teamId: currentUser?.teamId || 9, // ÎëêÏÇ∞ Î≤†Ïñ¥Ïä§ Í∏∞Î≥∏Í∞í
            nickname: currentUser?.nickname || 'Anonymous',
            userId: currentUser?.userId || currentUserId
          };
        } else {
          authData = {
            type: 'AUTH',
            matchId: room.matchId,
            nickname: currentUser?.nickname || 'Anonymous',
            winRate: 75,
            profileImgUrl: currentUser?.profileImageURL || '',
            isWinFairy: false
          };
        }
        
        websocket.send(JSON.stringify(authData));
      };

      websocket.onmessage = (event) => {
        // Î©îÏãúÏßÄ Ï≤òÎ¶¨ Î°úÏßÅ (Í∏∞Ï°¥Í≥º ÎèôÏùº)
        try {
          const messageData = JSON.parse(event.data);
          
          if (typeof messageData.timestamp === 'number') {
            messageData.timestamp = new Date(messageData.timestamp).toISOString();
          }
          
          const messageKey = `${messageData.content}_${messageData.timestamp}`;
          const isMyMessage = messageData.userId && (
            messageData.userId.toString() === currentUserId.toString() ||
            messageData.userId.toString() === currentUser?.userId?.toString()
          ) || (!isWatchChat && messageData.nickname === currentUser?.nickname);
          
          
          
          if (messageData.messageType === 'CHAT' || messageData.type === 'CHAT_MESSAGE') {
            const content = messageData.content || '';
            
            const isAuthDataMessage = typeof content === 'string' && (
              content.includes('"matchId"') && content.includes('"winRate"') ||
              content.includes('"gameId"') && content.includes('"teamId"') ||
              content.includes('"isWinFairy"') ||
              content.includes('"profileImgUrl"')
            );
              
            if (!isAuthDataMessage) {
              if (isWatchChat) {
                // ÏßÅÍ¥ÄÏ±ÑÌåÖ: Îã®ÏàúÌïòÍ≤å Î©îÏãúÏßÄ Ï∂îÍ∞Ä
                addMessage(messageData, isMyMessage);
              } else {
                // Îß§ÏπòÏ±ÑÌåÖ: ÎÇ¥ Î©îÏãúÏßÄÏù∏ Í≤ΩÏö∞ Î°úÏª¨ Î©îÏãúÏßÄÎ•º ÏÑúÎ≤Ñ Î©îÏãúÏßÄÎ°ú ÍµêÏ≤¥
                if (isMyMessage) {
                  setMessages(prev => {
                    // Í∞ôÏùÄ ÎÇ¥Ïö©Ïùò Î°úÏª¨ Î©îÏãúÏßÄ Ï†úÍ±∞ (pending Î©îÏãúÏßÄ)
                    const filtered = prev.filter(m => 
                      !(m.content === messageData.content && (m as any)._isMyMessage && m.status)
                    );
                    
                    // ÏÑúÎ≤Ñ Î©îÏãúÏßÄ Ï∂îÍ∞Ä
                    const serverMessage = {
                      ...messageData,
                      _isMyMessage: true
                    };
                    
                    const newMessages = [...filtered, serverMessage];
                    newMessages.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
                    return newMessages;
                  });
                } else {
                  // Îã§Î•∏ ÏÇ¨Ïö©Ïûê Î©îÏãúÏßÄÎäî Í∑∏ÎåÄÎ°ú Ï∂îÍ∞Ä
                  addMessage(messageData, isMyMessage);
                }
              }
            }
          } else if (
            messageData.messageType === 'USER_JOIN' ||
            messageData.messageType === 'USER_LEAVE'
          ) {
            addMessage(messageData, false);
          }
        } catch (error) {
          console.error('Î©îÏãúÏßÄ ÌååÏã± Ïò§Î•ò:', error);
        }
      };

      websocket.onclose = (event) => {
        clearTimeout(connectionTimeout);
        state.isConnecting = false;
        state.isConnected = false;
        setConnectionStatus('DISCONNECTED');
        console.log(`ÏõπÏÜåÏºì Ïó∞Í≤∞ Ï¢ÖÎ£å: ${event.code} - ${event.reason}`);
        
        // ÏÇ¨Ïö©ÏûêÏóêÍ≤å Ïó∞Í≤∞ ÎÅäÏñ¥Ïßê ÏïåÎ¶º (Ï†ïÏÉÅ Ï¢ÖÎ£åÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞Îßå)
        if (event.code !== 1000 && !state.isDestroyed) {
          const error = getErrorMessage({
            type: 'close',
            code: event.code,
            reason: event.reason
          });
          logChatError(error, { code: event.code, reason: event.reason });
          showErrorNotification(error);
          
          scheduleReconnect();
        }
      };

      websocket.onerror = (error) => {
        clearTimeout(connectionTimeout);
        state.isConnecting = false;
        state.isConnected = false;
        setConnectionStatus('ERROR');
        console.error('ÏõπÏÜåÏºì Ïò§Î•ò:', error);
        
        if (!state.isDestroyed) {
          const chatError = getErrorMessage({
            type: 'CONNECTION_ERROR',
            message: 'WebSocket connection error'
          });
          logChatError(chatError, { originalError: error });
          showErrorNotification(chatError, () => {
            // ÏÇ¨Ïö©ÏûêÍ∞Ä Ïû¨ÏãúÎèÑ Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠ÌïòÎ©¥ Ï¶âÏãú Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ
            connectToWebSocket();
          });
          
          scheduleReconnect();
        }
      };

    } catch (error) {
      state.isConnecting = false;
      setConnectionStatus('ERROR');
      console.error('ÏõπÏÜåÏºì Ïó∞Í≤∞ Ïò§Î•ò:', error);
      scheduleReconnect();
    }
  }, [websocketUrl, sessionToken, canReconnect, ws, isWatchChat, room, currentUser, currentUserId, sentMessages, addMessage]);

  // üîß FIX 6: Ïû¨Ïó∞Í≤∞ Ïä§ÏºÄÏ§ÑÎßÅ Ìï®Ïàò Î∂ÑÎ¶¨
  const scheduleReconnect = useCallback(() => {
    const state = connectionStateRef.current;
    
    if (!canReconnect()) {
      return;
    }

    clearReconnectTimer();
    
    state.reconnectAttempts++;
    const backoffDelay = Math.min(Math.pow(2, state.reconnectAttempts - 1) * 1000, 10000);
    
    console.log(`üîÑ Ïû¨Ïó∞Í≤∞ ÏòàÏïΩ: ${state.reconnectAttempts}/${state.maxReconnectAttempts} (${backoffDelay}ms ÌõÑ)`);
    
    // Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ ÏïåÎ¶º ÌëúÏãú
    setConnectionStatus('RECONNECTING');
    showConnectionNotification('RECONNECTING', state.reconnectAttempts, state.maxReconnectAttempts);
    
    state.reconnectTimer = setTimeout(() => {
      if (!state.isDestroyed && canReconnect()) {
        setConnectionStatus('CONNECTING');
        connectToWebSocket();
      }
    }, backoffDelay);
  }, [canReconnect, connectToWebSocket, clearReconnectTimer, showConnectionNotification]);

  const disconnect = useCallback(() => {
    const state = connectionStateRef.current;
    
    // Ïù¥ÎØ∏ Ìï¥Ï†úÎêú Í≤ΩÏö∞ Ï§ëÎ≥µ Ïã§Ìñâ Î∞©ÏßÄ
    if (state.isDestroyed) {
      console.log('üì± WebSocket Ïù¥ÎØ∏ Ìï¥Ï†úÎê® - Ï§ëÎ≥µ Ìò∏Ï∂ú Î¨¥Ïãú');
      return;
    }
    
    console.log('üì± WebSocket Ïó∞Í≤∞ Ìï¥Ï†ú');
    
    state.isDestroyed = true;
    state.isConnecting = false;
    state.isConnected = false;
    
    clearReconnectTimer();
    
    if (ws && ws.readyState === WebSocket.OPEN) {
      try {
        ws.close(1000, 'Client disconnect');
      } catch (error) {
        console.log('üì± WebSocket Ï¢ÖÎ£å Ï§ë ÏóêÎü¨ (Î¨¥Ïãú):', error);
      }
    }
    setWs(null);
    
    setConnectionStatus('DISCONNECTED');
    setSentMessages(new Set());
  }, [ws, clearReconnectTimer]);

  const sendMessage = useCallback(async () => {
    if (!currentMessage.trim()) return;

    const messageContent = currentMessage.trim();
    
    // Ï¶âÏãú ÏûÖÎ†• ÌïÑÎìú ÌÅ¥Î¶¨Ïñ¥ (ÏÇ¨Ïö©Ïûê Í≤ΩÌóò Í∞úÏÑ†)
    setCurrentMessage('');
    
    try {
      // Î©îÏãúÏßÄ ÌÅêÏóê Ï∂îÍ∞Ä (ÏûêÎèôÏúºÎ°ú Ï†ÑÏÜ° ÏãúÎèÑ)
      const messageId = await addMessageToQueue(messageContent);
      
      // Îß§ÏπòÏ±ÑÌåÖÏóêÏÑúÎßå Î°úÏª¨ÏóêÏÑú Ï¶âÏãú Î©îÏãúÏßÄ ÌëúÏãú (ÎÇôÍ¥ÄÏ†Å ÏóÖÎç∞Ïù¥Ìä∏)
      if (!isWatchChat) {
        const timestamp = new Date().toISOString();
        const localMessage: MessageWithStatus = {
          messageType: 'CHAT',
          roomId: room.matchId || '',
          userId: currentUser?.userId?.toString() || currentUserId.toString(),
          nickname: currentUser?.nickname || 'Anonymous',
          content: messageContent,
          timestamp,
          id: messageId,
          status: 'sent',
          _isMyMessage: true,
        };
        
        addMessage(localMessage, true);
      }
      
      console.log('Î©îÏãúÏßÄ ÌÅêÏóê Ï∂îÍ∞Ä:', messageContent);
    } catch (error) {
      console.error('Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïò§Î•ò:', error);
      const chatError = getErrorMessage({
        type: 'MESSAGE_SEND',
        message: error instanceof Error ? error.message : 'Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïã§Ìå®'
      });
      logChatError(chatError, { content: messageContent });
      showErrorNotification(chatError);
      
      // Ïã§Ìå® Ïãú ÏûÖÎ†• ÌïÑÎìú Î≥µÏõê
      setCurrentMessage(messageContent);
    }
  }, [currentMessage, addMessageToQueue, addMessage, room, currentUser, currentUserId, showErrorNotification]);

  // üîß FIX 7: useEffect ÏùòÏ°¥ÏÑ± Î∞∞Ïó¥ ÏµúÏ†ÅÌôî
  
  // inverted FlatList ÏÇ¨Ïö©ÏúºÎ°ú ÏûêÎèô Ïä§ÌÅ¨Î°§ Ï≤òÎ¶¨Îê®

  // Ï¥àÍ∏∞ Ïó∞Í≤∞ (Ìïú Î≤àÎßå)
  useEffect(() => {
    console.log('üì± MatchChatRoomScreen ÎßàÏö¥Ìä∏Îê® - WebSocket Ïó∞Í≤∞ ÏãúÏûë');
    
    const timer = setTimeout(() => {
      connectToWebSocket();
    }, 500);
    
    return () => {
      clearTimeout(timer);
    };
  }, []); // ÏùòÏ°¥ÏÑ± Î∞∞Ïó¥ ÎπÑÏõÄ

  // AppState Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà (Ìïú Î≤àÎßå Îì±Î°ù)
  useEffect(() => {
    const handleAppStateChange = (nextAppState: string) => {
      console.log('üì± Ïï± ÏÉÅÌÉú Î≥ÄÌôî:', appState, '‚Üí', nextAppState);
      
      const prevAppState = appState;
      setAppState(nextAppState);
      
      // background -> active Î≥µÍ∑Ä ÏãúÏóêÎßå Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ
      if (prevAppState.match(/inactive|background/) && nextAppState === 'active') {
        console.log('üì± Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú Î≥µÍ∑Ä - WebSocket ÏÉÅÌÉú ÌôïÏù∏');
        setTimeout(() => {
          if (canReconnect()) {
            console.log('üì± Î∞±Í∑∏ÎùºÏö¥Îìú Î≥µÍ∑Ä Ïãú WebSocket Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ');
            connectToWebSocket();
          }
        }, 1000);
      }
    };

    const subscription = AppState.addEventListener('change', handleAppStateChange);
    return () => subscription?.remove();
  }, [appState, canReconnect, connectToWebSocket]); // ÏïàÏ†ïÏ†ÅÏù∏ ÏùòÏ°¥ÏÑ±Îßå Ìè¨Ìï®

  // ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò Ïù¥Î≤§Ìä∏ (Ìïú Î≤àÎßå Îì±Î°ù)
  useEffect(() => {
    const unsubscribeBeforeRemove = navigation.addListener('beforeRemove', () => {
      console.log('üì± ÌôîÎ©¥ Ï†úÍ±∞ ÏßÅÏ†Ñ - WebSocket Ïó∞Í≤∞ Ìï¥Ï†ú');
      disconnect();
    });

    return () => {
      unsubscribeBeforeRemove();
    };
  }, [navigation, disconnect]);

  // ÎÑ§Ìä∏ÏõåÌÅ¨ ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ (Ìïú Î≤àÎßå Îì±Î°ù)
  useEffect(() => {
    const unsubscribe = NetInfo.addEventListener(state => {
      const isConnected = state.isConnected ?? false;
      console.log('üåê ÎÑ§Ìä∏ÏõåÌÅ¨ ÏÉÅÌÉú Î≥ÄÌôî:', { isConnected, type: state.type });
      
      const prevNetworkConnected = networkConnected;
      setNetworkConnected(isConnected);
      
      if (!isConnected) {
        // Ïò§ÌîÑÎùºÏù∏ ÏÉÅÌÉú ÏïåÎ¶º
        setConnectionStatus('OFFLINE');
        showConnectionNotification('OFFLINE');
        
        if (ws) {
          console.log('üåê ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ ÎÅäÏñ¥Ïßê - WebSocket Ïó∞Í≤∞ Ìï¥Ï†ú');
          ws.close(1000, 'Network disconnected');
        }
      } else if (isConnected && !prevNetworkConnected && appState === 'active') {
        // Ïò®ÎùºÏù∏ Î≥µÍµ¨ Ïãú ÏïåÎ¶º Î∞è Ïû¨Ïó∞Í≤∞
        console.log('üåê ÎÑ§Ìä∏ÏõåÌÅ¨ Îã§Ïãú Ïó∞Í≤∞Îê® - WebSocket Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ');
        
        setTimeout(() => {
          if (canReconnect()) {
            setConnectionStatus('CONNECTING');
            connectToWebSocket();
          }
        }, 2000);
      }
    });

    return () => unsubscribe();
  }, [networkConnected, ws, appState, canReconnect, connectToWebSocket, showConnectionNotification]);

  // Í≤åÏûÑ Ï†ïÎ≥¥ Î°úÎìú
  useEffect(() => {
    const loadGameInfo = async () => {
      if (room.gameId) {
        try {
          const response = await gameApi.getGameById(room.gameId.toString());
          if (response.status === 'SUCCESS') {
            setGameInfo(response.data);
          }
        } catch (error) {
          console.error('Í≤åÏûÑ Ï†ïÎ≥¥ Î°úÎìú Ïã§Ìå®:', error);
        }
      }
    };
    
    loadGameInfo();
  }, [room.gameId]);

  // Ïª¥Ìè¨ÎÑåÌä∏ Ïñ∏ÎßàÏö¥Ìä∏ Ïãú Ï†ïÎ¶¨
  useEffect(() => {
    return () => {
      console.log('üì± MatchChatRoomScreen Ïñ∏ÎßàÏö¥Ìä∏Îê®');
      disconnect();
    };
  }, []); // disconnectÎ•º dependencyÏóêÏÑú Ï†úÍ±∞

  return (
    <View style={[styles.container, { paddingTop: insets.top }]}>
      <KeyboardAvoidingView 
        style={styles.container}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 0 : 0}
      >
        {/* ÏïåÎ¶º Í¥ÄÎ¶¨Ïûê */}
        <ChatNotificationManager
          notifications={notifications}
          onDismiss={dismissNotification}
        />

        {/* Ìó§Îçî */}
        <View style={[styles.header, { backgroundColor: themeColor }]}>
          <TouchableOpacity
            onPress={() => navigation.goBack()}
            style={styles.backButton}
          >
            <Text style={styles.backButtonText}>‚Üê</Text>
          </TouchableOpacity>
          <View style={styles.headerContent}>
            <View style={styles.headerTitleRow}>
              <Text style={styles.headerTitle}>
                {isWatchChat ? 'ÏßÅÍ¥ÄÏ±ÑÌåÖ' : room.matchTitle || 'Îß§ÏπòÏ±ÑÌåÖ'}
              </Text>
              <SimpleConnectionStatus status={connectionStatus} />
            </View>
            {gameInfo && (
              <Text style={styles.headerSubtitle}>
                {gameInfo.awayTeamName} vs {gameInfo.homeTeamName}
              </Text>
            )}
            <ConnectionStatusIndicator 
              status={connectionStatus}
              reconnectAttempts={connectionStateRef.current.reconnectAttempts}
              maxReconnectAttempts={connectionStateRef.current.maxReconnectAttempts}
            />
          </View>
        </View>

        {/* Î©îÏãúÏßÄ Î™©Î°ù */}
        <FlatList
          ref={flatListRef}
          style={styles.messagesList}
          contentContainerStyle={styles.messagesContent}
          data={[...messages, ...pendingMessages.map(p => ({ ...p, _isPending: true }))].reverse()}
          keyExtractor={(item, index) => item.id || index.toString()}
          onEndReached={loadOlderMessages}
          onEndReachedThreshold={0.1}
          ListFooterComponent={
            isLoadingOlderMessages ? (
              <View style={styles.loadingContainer}>
                <ActivityIndicator color="#666" />
                <Text style={styles.loadingText}>Ïù¥Ï†Ñ Î©îÏãúÏßÄ Î°úÎìú Ï§ë...</Text>
              </View>
            ) : null
          }
          renderItem={({ item }) => (
            <View style={styles.messageItem}>
              {(item.messageType === 'CHAT' || item.type === 'CHAT_MESSAGE') ? (
                <View style={[
                  styles.messageRow,
                  ((item as any)._isMyMessage || (item as any)._isPending) ? styles.myMessageRow : styles.otherMessageRow
                ]}>
                  {/* ÌîÑÎ°úÌïÑ ÏÇ¨ÏßÑ (ÎÇ¥ Î©îÏãúÏßÄÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞Îßå) */}
                  {!((item as any)._isMyMessage || (item as any)._isPending) && (
                    <Image 
                      source={{ 
                        uri: (item as MatchChatMessage).profileImgUrl || 'https://via.placeholder.com/40x40/cccccc/666666?text=?' 
                      }}
                      style={styles.profileImage}
                    />
                  )}
                  
                  {/* Î©îÏãúÏßÄ ÏòÅÏó≠ */}
                  <View style={[
                    styles.messageBubbleContainer,
                    ((item as any)._isMyMessage || (item as any)._isPending) ? styles.myMessageBubbleContainer : styles.otherMessageBubbleContainer
                  ]}>
                    {/* ÎãâÎÑ§ÏûÑ (ÎÇ¥ Î©îÏãúÏßÄÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞Îßå) */}
                    {!((item as any)._isMyMessage || (item as any)._isPending) && (
                      <Text style={styles.messageNickname}>
                        {(item as MatchChatMessage).nickname}
                      </Text>
                    )}
                    
                    {/* ÎßêÌíçÏÑ†Í≥º ÏãúÍ∞ÑÏùÑ Îã¥Îäî Ïª®ÌÖåÏù¥ÎÑà */}
                    <View style={[
                      styles.bubbleAndTimeContainer,
                      ((item as any)._isMyMessage || (item as any)._isPending) ? styles.myBubbleAndTimeContainer : styles.otherBubbleAndTimeContainer
                    ]}>
                      {/* ÏãúÍ∞Ñ (ÎÇ¥ Î©îÏãúÏßÄÏù∏ Í≤ΩÏö∞ ÏôºÏ™ΩÏóê) */}
                      {((item as any)._isMyMessage || (item as any)._isPending) && (
                        <Text style={styles.myMessageTime}>
                          {new Date(item.timestamp).toLocaleTimeString('ko-KR', { 
                            hour: '2-digit', 
                            minute: '2-digit' 
                          })}
                        </Text>
                      )}
                      
                      {/* ÎßêÌíçÏÑ† */}
                      <View style={[
                        styles.chatMessage,
                        ((item as any)._isMyMessage || (item as any)._isPending) ? styles.myMessage : styles.otherMessage
                      ]}>
                        <Text style={[
                          ((item as any)._isMyMessage || (item as any)._isPending) ? styles.myMessageContent : styles.messageContent
                        ]}>
                          {item.content}
                        </Text>
                      </View>
                      
                      {/* ÏãúÍ∞Ñ (Îã§Î•∏ ÏÇ¨Ïö©Ïûê Î©îÏãúÏßÄÏù∏ Í≤ΩÏö∞ Ïò§Î•∏Ï™ΩÏóê) */}
                      {!((item as any)._isMyMessage || (item as any)._isPending) && (
                        <Text style={styles.otherMessageTime}>
                          {new Date(item.timestamp).toLocaleTimeString('ko-KR', { 
                            hour: '2-digit', 
                            minute: '2-digit' 
                          })}
                        </Text>
                      )}
                    </View>
                  </View>
                </View>
              ) : (
                <View style={styles.systemMessage}>
                  <Text style={styles.systemMessageText}>{item.content}</Text>
                </View>
              )}
            </View>
          )}
          inverted
          showsVerticalScrollIndicator={false}
        />

        {/* Î©îÏãúÏßÄ ÏûÖÎ†• */}
        <View style={styles.messageInput}>
          <TextInput
            style={styles.textInput}
            value={currentMessage}
            onChangeText={setCurrentMessage}
            placeholder="Î©îÏãúÏßÄÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî..."
            multiline
            maxLength={500}
          />
          <TouchableOpacity
            style={[
              styles.sendButton,
              { backgroundColor: themeColor },
              !currentMessage.trim() && styles.sendButtonDisabled
            ]}
            onPress={sendMessage}
            disabled={!currentMessage.trim() || connectionStatus !== 'CONNECTED'}
          >
            <Text style={styles.sendButtonText}>Ï†ÑÏÜ°</Text>
          </TouchableOpacity>
        </View>
      </KeyboardAvoidingView>
    </View>
  );
};