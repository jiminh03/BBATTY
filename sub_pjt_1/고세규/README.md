# 주간 학습 기록
**기간**: 2025년 7월 14일 ~ 7월 18일  
**프로젝트: 빠티(BBATTY)**   
직관 인증부터 팀 커뮤니티, 실시간 채팅, 승률 기록까지 야구팬의 직관 경험을 연결하는 통합 플랫폼

---

## 이번 주 학습 목표
- 프로젝트 주제 선정 및 기획
- 기능 명세서 작성
- 채팅 시스템에서 redis만 사용한 시스템 도입 결정을 위한 공부 (자료구조, redis pub/sub)

---


### 1. 프로젝트 주제 선정 및 기획


**배운 점:**
- 아이디어 선정에 있어서 중간에 아이템이 한번 변경되면서 오히려 좋은 프로젝트와 아이템에 대해 다시 생각해볼 수 있는 계기가 되었다..
    - 단순히 고객 니즈와 페인포인트뿐만 아니라 포트폴리오 측면에서 적절할 볼륨을 설정하는 것 또한 학습적인 면에서 중요하다.
    - 모든 팀원이 흥미있어야 프로젝트가 열정적으로 진행된다.

- 아이디어 기획에 있어서 핵심 가치, 페르소나를 생성하고 진행하니 추후 기능 명세 등의 작업시에 판단의 기준이 되어서 유용했다.


### 2. 기능 명세서 작성

**진행 방식**
- 전반적인 아이디어 기획서를 자세하게 작성하여 팀원간의 아이템에 대한 이해를 통일시킨다..
- 페이지 별로 작성하였으며 해당 페이지에 들어갈 기능을 유저 관점으로 모두 작성한다.
- 기본적으로는 최종 프로젝트를 기준으로 하며 MVP 체크박스 항목을 넣어서 초기 개발 하는 기능을 구분하였다.

**배운점**
- 기능명세서는 시간이 걸리더라도 다함께 꼼꼼히 작성하는 것이 추후 개발 단계에서 의견 충돌, 소통 오류가 없어서 중요하다.

---

### redis 공부 (자료구조, redis pub/sub)

1. 학습 배경
좋아요, 대시보드, 캐싱, 채팅 등 여러가지의 기능 구현을 Redis로 하게될 것으로 예상되어 더욱 심도깊게 공부해봤다.

---

####  redis 자료구조
https://redis.io/docs/latest/develop/data-types/
위의 공식문서를 기반으로 공부하였다.
개인 노션에 정리해두었으며 여기에는 간략하게 알아간 부분만 작성하였습니다.

1. string
- 내부적으로 바이트 배열로 저장 -> 이미지와 같은 자료도 처리 가능

2. list 
- 삽입 순서대로 정렬된 문자열 목록
- 내부적으로 Linked List로 구현
- 블로킹 큐 구현 가능
- 최신 N개의 항목만 유지하고 싶을 때 LTRIM 명령을 통한 제한 큐

3. set
- 고유한 문자열(멤버)의 순서 없는 컬렉션
- 다른 언어의 set과 유사
좋아요 구현할 때 사용하면 좋을거 같다고 생각

4. Sorted Set
- 각 문자열 요소가 점수(score)와 함께 저장
- 요소 추가/수정 시 O(log N) 시간 복잡도
- 업데이트가 빈번한 경우에 적합
- 요소 이름은 유일해야 한다.
- ZRANK 을 통해 등수 조회
- 점수 범위 조회도 가능
대시보드 구현시 사용하면 좋을거 같다고 생각

5. stream
- append-only 로그 구조의 데이터 타입
    - 새로운 데이터는 맨 뒤에만 추가
    - 각 항목은 고유 ID로 직접 접근 가능 (O(1) 시간 복잡도)
    - 여러 소비자가 하나의 스트림을 분산 처리 가능
    - 메시지 분배, 실패 복구, 순서 보장 등 고급 메시지 처리 기능 제공

- 주요 사용 용도
    - 실시간 로그 처리
    - 이벤트 스트리밍 처리
    - Kafka와 유사하지만 브로드 캐스팅에 최적화되어 있지 않다.

**자료 구조 모습**

로그 구조를 따른다 → 시간 순서대로 데이터가 쌓이는 형태이다.

즉 하나의 스트림은 아래와 같이 생겼다.

```java
Key: chat:room1
  ├─ Entry 1: 1721190000000-0 → { sender=user1, message="Hi there!" }
  ├─ Entry 2: 1721190000001-0 → { sender=user2, message="Hello!" }
  └─ Entry 3: 1721190000002-0 → { sender=user3, message="How are you?" }
```

이렇게 해서 add하여 stream 넣고 read하면 특정 ID나 처음부터 읽기 가능
그리고 block를 통해 기다렸다가 스트림에 들어오면 읽을 수도 있다.

소비자 그룹:  하나의 스트림을 여러 소비자가 나눠서 읽도록 하여 메시지를 병렬 처리하고 중복 소비를 방지하는 구조

이를 통해 > 같은 명령어로 소비자 그룹애서 안 읽은 메세지 가져올 수 있다. (받으면 ACK 보내줘야 읽음 처리 됨)
-> 채팅에 쓸수 있겠는데..? 싶었지만

문제:  Redis Stream이 Work Queue 방식으로 설계되었다.
- 채팅방에 5명의 사용자가 있다고 가정
- 1, 2, 3, 4번 사용자가 메시지를 받지 못함
- 그런데 1, 2, 3, 4번 중 **아무나 한 명**이 `XACK`을 보내면 해당 메시지는 "처리됨" 상태가 됨
- 결과적으로 메시지를 받지 못한 사용자들도 스트림이 읽음처리 해버린다. 

즉  consumer들이 협업하여 메시지를 나눠서 처리하는거지 메세지를 브로드캐스팅하지 않는다.

이를 해결하기 위해 pubsub과도 같이 쓴다.


#### redis pub/sub

**pub/sub**

1. **채널(Channel)**: 메시지가 흐르는 통로
2. **발행자(Publisher)**: 메시지를 보내는 역할
3. **구독자(Subscriber)**: 메시지를 수신하는 객체


1. **채널 관리**: Redis는 내부에 채널이라는 단위로 메시지를 구분한다
2. **구독자 목록 저장**: 구독자들이 특정 채널을 구독하면 해당 클라이언트를 목록에 저장한다
3. **브로드캐스트**: 채널에 메시지가 도착하면 구독자 목록을 참조하여 모든 클라이언트에게 실시간으로 전송한다

이러면 브로드 캐스팅을 할 순 있지만 redis가 ack을 했던 것처럼 그러한 신뢰적인 전송 보장 기능이 없다.
그냥 redis는 구독자들한테 쐈으면 끝이다.
그리고 보낸 메세지를 따로 저장하지도 않는다. 그냥 "어? 왔네? 구독자들한테 뿌려야지? 이다.

**어떻게 pub/sub와 stream을 쓰냐**
- 메세지를 발행할 때 stream도 만들고 publish도 한다.
- 그럼 이전의 메세지는 stream에 저장되어 있기 때문에 사용자가 다시 읽을 수 있다. (이러면 마지막읽은 메세지를 저장하던지 아니면 모두 읽던지) <- 이게 좀 좋지 않아 보임
- 또한 stream과 publish를 트렌젝션 처리해야 한다.

결론 : 
경기 채팅방(이전 메세지 안 보여줘도 된다., 메세지의 중요도 낮음) : pubsub 보류
매칭 채팅방(이전 메세지 보여줘야 함, 메세지의 중요도 높음) : redis만을 쓸 순 없을 듯, Kafka, rabbitMQ 등의 메세지 큐 도입 예정


## 학습 회고
모르는 기술에 대해 알아가는 것이 재밌었다.
특히 명확한 상황이 주어지니 선택하는 과정에서 더 깊은 고민을 할 수 있었다.

### 잘한 점
기초부터 redis에 대해 알아가서 선택을 나름 근거 있게 진행하였다.

### 아쉬운 점
개념을 이해하는데에 시간이 좀 걸렸다. 이런 구조를 처음보고 cs적인 지식이 부족하여 그런듯하다.

### 개선 방향
기술의 도입 여부를 결정할 때는 해당 스택의 자료구조, 기본 명령어 등을 학습하겠다.
이때의 빠른 이해를 위해 틈틈히 cs와 기술 스택의 기초 정보를 많이 공부해 놓겠다.

---